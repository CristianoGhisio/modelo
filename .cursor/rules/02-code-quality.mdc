---
description: "PadrÃµes de qualidade de cÃ³digo e implementaÃ§Ã£o baseados na metodologia THINK"
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# ğŸ”§ QUALIDADE DE CÃ“DIGO - PADRÃ•ES MODERNOS 2024

## âš¡ PRINCÃPIOS FUNDAMENTAIS

### ğŸ¯ **Minimal Viable Fix**
- Sempre implementar a menor alteraÃ§Ã£o que resolve o problema
- Evitar over-engineering e soluÃ§Ãµes complexas desnecessÃ¡rias
- Priorizar clareza e simplicidade sobre "cleverness"

### ğŸ”’ **Type Safety First**
- TypeScript rigoroso + validaÃ§Ã£o runtime
- Interfaces explÃ­citas para todos os contratos
- Evitar `any` - usar `unknown` quando necessÃ¡rio
- ValidaÃ§Ã£o de dados na entrada de funÃ§Ãµes crÃ­ticas

### ğŸ›¡ï¸ **Defensive Programming**
- Sempre validar inputs e outputs
- Implementar fallbacks graceful para falhas
- Nunca assumir que dados externos estÃ£o corretos
- Logging estratÃ©gico em pontos crÃ­ticos

## ğŸ“Š PADRÃ•ES DE IMPLEMENTAÃ‡ÃƒO

### ğŸ” **Logging Defensivo ObrigatÃ³rio**
```typescript
// âœ… CORRETO: Logging estruturado
console.log('ğŸ” Auth Check:', {
  hasToken: !!token,
  tokenValid: token?.length > 10,
  userRoles: user?.roles,
  timestamp: new Date().toISOString()
});

// âŒ INCORRETO: Logging sem contexto
console.log('auth ok');
```

### ğŸ“¡ **API Communication Pattern**
```typescript
// âœ… CORRETO: ComunicaÃ§Ã£o com logs e tratamento
const apiCall = async (endpoint: string, data?: any) => {
  const traceId = generateTraceId();
  
  console.log('ğŸ“¡ API Call:', {
    method: 'POST',
    endpoint,
    traceId,
    payload: sanitizePayload(data)
  });

  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });

    console.log('ğŸ“¥ API Response:', {
      status: response.status,
      traceId,
      success: response.ok
    });

    return response.json();
  } catch (error) {
    console.error('âŒ API Error:', {
      endpoint,
      error: error.message,
      traceId
    });
    throw error;
  }
};
```

### ğŸ”„ **Data Processing Pattern**
```typescript
// âœ… CORRETO: Processamento defensivo
const processApiResponse = <T>(
  response: ApiResponse<T>,
  options: ProcessingOptions = {}
): ProcessedData<T> => {
  console.log('ğŸ” Processing API Response:', {
    status: response?.status,
    hasData: !!response?.data,
    dataType: response?.data ? typeof response.data : 'undefined'
  });

  try {
    // MÃºltiplas estratÃ©gias de fallback
    const rawData = response?.data ?? response?.items ?? response?.result ?? [];
    
    // NormalizaÃ§Ã£o segura
    const normalizedData = Array.isArray(rawData) 
      ? rawData 
      : [rawData].filter(Boolean);
    
    console.log('âœ… Processing Success:', {
      inputType: typeof rawData,
      outputCount: normalizedData.length
    });
    
    return {
      data: normalizedData,
      meta: {
        processedAt: new Date().toISOString(),
        count: normalizedData.length
      }
    };
    
  } catch (error) {
    console.error('âŒ Processing Failed:', {
      error: error.message,
      response: sanitizeForLogging(response)
    });
    
    // Fallback graceful
    return {
      data: [],
      meta: {
        error: error.message,
        processedAt: new Date().toISOString()
      }
    };
  }
};
```

## âš›ï¸ REACT PATTERNS MODERNOS

### ğŸ¯ **Custom Hooks Pattern**
```typescript
// âœ… CORRETO: Hook composÃ¡vel e reutilizÃ¡vel
const useFeature = (options: UseFeatureOptions = {}) => {
  const { enabled = true, onSuccess, onError } = options;
  
  return useQuery({
    queryKey: ['feature', options],
    queryFn: () => featureService.getData(),
    enabled,
    retry: 3,
    staleTime: 5 * 60 * 1000, // 5min
    onSuccess,
    onError,
    meta: {
      traceId: generateTraceId(),
      component: 'useFeature'
    }
  });
};
```

### ğŸ›¡ï¸ **Error Boundary Pattern**
```typescript
// âœ… CORRETO: Error boundary com logging
const ErrorBoundaryProvider = ({ children }: PropsWithChildren) => (
  <ErrorBoundary
    FallbackComponent={ErrorFallback}
    onError={(error, errorInfo) => {
      console.error('Component Error:', {
        error: error.message,
        stack: error.stack,
        componentStack: errorInfo.componentStack,
        userId: getCurrentUser()?.id,
        timestamp: new Date().toISOString()
      });
    }}
  >
    <Suspense fallback={<SkeletonLoader />}>
      {children}
    </Suspense>
  </ErrorBoundary>
);
```

## ğŸš« ANTI-PATTERNS A EVITAR

### âŒ **Double Data Access**
```typescript
// âŒ INCORRETO: ServiÃ§o jÃ¡ faz parsing
const data = JSON.parse(service.getData()); // ServiÃ§o jÃ¡ retorna objeto

// âœ… CORRETO: Confiar no serviÃ§o
const data = service.getData();
```

### âŒ **Undefined Checks DesnecessÃ¡rios**
```typescript
// âŒ INCORRETO: VerificaÃ§Ã£o redundante
if (data && data.length && data.length > 0) {
  // ...
}

// âœ… CORRETO: VerificaÃ§Ã£o concisa
if (data?.length) {
  // ...
}
```

### âŒ **Type Mismatches**
```typescript
// âŒ INCORRETO: Assumir tipo sem validaÃ§Ã£o
const processUser = (user: any) => {
  return user.name.toUpperCase(); // Pode quebrar
};

// âœ… CORRETO: ValidaÃ§Ã£o de tipo
const processUser = (user: User) => {
  if (!user?.name || typeof user.name !== 'string') {
    console.warn('Invalid user name:', user);
    return 'Unknown User';
  }
  return user.name.toUpperCase();
};
```

## ğŸ“‹ CHECKLIST DE CÃ“DIGO

### âœ… **Antes de Commit**
- [ ] Logging implementado em pontos crÃ­ticos
- [ ] Tratamento de erro graceful
- [ ] Types explÃ­citos e validados
- [ ] Fallbacks para cenÃ¡rios de falha
- [ ] Performance considerada (evitar re-renders desnecessÃ¡rios)
- [ ] Accessibility bÃ¡sica (ARIA labels quando necessÃ¡rio)
- [ ] Mobile responsiveness verificada

### âœ… **Antes de Deploy**
- [ ] Testes unitÃ¡rios passando
- [ ] Edge cases cobertos
- [ ] Error boundaries implementadas
- [ ] Loading states adequados
- [ ] Success/error messages claras
- [ ] Performance < 3s para operaÃ§Ãµes principais
- [ ] Sem console.logs de debug em produÃ§Ã£o 