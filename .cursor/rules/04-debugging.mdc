---
description: "EstratÃ©gias de debugging e investigaÃ§Ã£o baseadas na metodologia THINK"
globs: ["**/*"]
alwaysApply: true
---

# ğŸ” DEBUGGING E INVESTIGAÃ‡ÃƒO - ESTRATÃ‰GIAS SISTEMÃTICAS

## âš¡ PRINCÃPIOS DE DEBUGGING

### ğŸ¯ **InvestigaÃ§Ã£o Paralela ObrigatÃ³ria**
**SEMPRE usar mÃºltiplas ferramentas simultaneamente:**
- `codebase_search`: PadrÃµes similares no projeto
- `grep_search`: Imports e exports relacionados
- `read_file`: Arquivos mencionados em logs
- `file_search`: Componentes relacionados
- `web_search`: SoluÃ§Ãµes modernas para o problema

### ğŸ” **Logging EstratÃ©gico por Camada**

#### ğŸŒ **Layer 1: Infrastructure & Network**
```typescript
console.log('ğŸŒ Network Check:', {
  endpoint: process.env.API_URL,
  timeout: connectionTimeout,
  retryCount: retryAttempts,
  timestamp: new Date().toISOString()
});

console.log('ğŸ“Š Performance:', {
  responseTime: Date.now() - startTime,
  memoryUsage: process.memoryUsage(),
  cpuUsage: process.cpuUsage()
});
```

#### ğŸ”— **Layer 2: API & Services**
```typescript
console.log('ğŸ” Auth Check:', {
  hasToken: !!token,
  tokenValid: token?.length > 10,
  userRoles: user?.roles,
  permissions: user?.permissions
});

console.log('ğŸ“¡ API Call:', {
  method: req.method,
  url: req.url,
  headers: sanitizeHeaders(req.headers),
  payload: sanitizePayload(req.body),
  correlationId: req.correlationId
});

console.log('ğŸ“¥ API Response:', {
  status: res.status,
  statusText: res.statusText,
  dataType: typeof res.data,
  dataSize: JSON.stringify(res.data || {}).length,
  correlationId: res.correlationId
});
```

#### âš›ï¸ **Layer 3: Frontend & UI**
```typescript
console.log('âš›ï¸ Component:', {
  name: ComponentName,
  phase: 'mount|update|unmount',
  props: sanitizeProps(props),
  state: sanitizeState(state),
  renderCount: renderCountRef.current++
});

console.log('ğŸ“Š Data Flow:', {
  received: !!data,
  processed: !!processedData,
  loading: isLoading,
  error: error?.message,
  cacheHit: isCacheHit
});

console.log('ğŸ”„ State Change:', {
  component: ComponentName,
  from: prevState,
  to: newState,
  trigger: actionType,
  timestamp: Date.now()
});
```

## ğŸ•µï¸ ESTRATÃ‰GIAS DE INVESTIGAÃ‡ÃƒO

### ğŸ” **Para Bugs de UI**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "componente relacionado"
- grep_search: "estilos CSS relacionados"
- file_search: "hooks e contexts"
- web_search: "react [erro especÃ­fico] 2024"
```

### ğŸ” **Para Bugs de API**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "endpoint relacionado"
- grep_search: "service layer"
- read_file: "controller + middleware"
- web_search: "nodejs [erro] best practices"
```

### ğŸ” **Para Bugs de Database**
```bash
# Execute SIMULTANEAMENTE:
- codebase_search: "schema relacionado"
- grep_search: "queries relacionadas"
- read_file: "migration files"
- web_search: "prisma [erro] solution"
```

## âš ï¸ ARMADILHAS COMUNS A EVITAR

### ğŸ” **Armadilhas TÃ©cnicas**
- **Double Data Access**: ServiÃ§os jÃ¡ fazem parsing
- **Type Mismatches**: TypeScript vs runtime
- **State Sync Issues**: Estado nÃ£o atualizado
- **Cache Invalidation**: Dados obsoletos
- **Race Conditions**: ConcorrÃªncia nÃ£o tratada
- **Memory Leaks**: Recursos nÃ£o liberados
- **Error Boundaries**: Erros nÃ£o capturados

### ğŸ—ï¸ **Armadilhas Arquiteturais**
- **Tight Coupling**: DependÃªncias desnecessÃ¡rias
- **Single Point of Failure**: Componente crÃ­tico Ãºnico
- **Over-Engineering**: SoluÃ§Ã£o mais complexa que o problema
- **Technical Debt**: SoluÃ§Ãµes temporÃ¡rias permanentes
- **Performance Bottlenecks**: Gargalos nÃ£o identificados

### ğŸ‘¥ **Armadilhas de Processo**
- **Assumption Bias**: Premissas nÃ£o validadas
- **Confirmation Bias**: Buscar sÃ³ evidÃªncias que confirmam
- **Scope Creep**: ExpansÃ£o nÃ£o controlada do problema
- **Communication Gap**: InformaÃ§Ãµes nÃ£o compartilhadas
- **Solution Bias**: Pular direto para implementaÃ§Ã£o

## ğŸ¯ MATRIZ DE PRIORIZAÃ‡ÃƒO DE HIPÃ“TESES

### ğŸ“Š **Sistema de Score 4D**
Para cada hipÃ³tese, avalie:
- **ğŸ“Š Probabilidade**: 1-10 (baseado em evidÃªncias)
- **ğŸ§ª Testabilidade**: 1-10 (facilidade de verificar)
- **ğŸ’¥ Impacto**: 1-10 (consequÃªncias se for a causa)
- **â±ï¸ Effort**: 1-10 (tempo/recursos para investigar/corrigir)

### ğŸ¯ **FÃ³rmula de PriorizaÃ§Ã£o**
```
Score = (Probabilidade Ã— 3) + (Impacto Ã— 2) + (10 - Effort) + Testabilidade
```

### ğŸ¥‡ **Matriz de ExecuÃ§Ã£o**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ SCORE > 30      â”‚ SCORE 20-30      â”‚ SCORE < 20       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ğŸ¥‡ PRIMEIRA     â”‚ ğŸ¥ˆ SEGUNDA       â”‚ ğŸ¥‰ TERCEIRA      â”‚
â”‚ (FÃ¡cil + Alta)  â”‚ (Balanceada)     â”‚ (DifÃ­cil/Baixa)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ PROTOCOLO DE ITERAÃ‡ÃƒO

### ğŸ“Š **Decision Matrix para PrÃ³ximos Passos**
```
ğŸ” ANÃLISE DE FALHA:
â”œâ”€â”€ ğŸ¯ HipÃ³tese Errada?
â”‚   â””â”€â”€ Voltar para PASSO 2 (REFLECT) com novos dados
â”œâ”€â”€ ğŸ› ï¸ ImplementaÃ§Ã£o Defeituosa?
â”‚   â””â”€â”€ Revisar PASSO 4 (EXECUTE) com feedback
â”œâ”€â”€ ğŸ“‹ Plano Inadequado?
â”‚   â””â”€â”€ Ajustar PASSO 3 (PLAN) baseado em learnings
â””â”€â”€ ğŸ§  Problema Mal Definido?
    â””â”€â”€ Retornar para PASSO 1 (THINK) para redefinir
```

### ğŸš¨ **Protocolo de SeguranÃ§a**
```typescript
interface IterationProtocol {
  maxIterations: number;        // MÃ¡ximo 3 iteraÃ§Ãµes
  timeboxing: number;          // MÃ¡ximo 8h por iteraÃ§Ã£o
  escalationTriggers: {
    timeExceeded: boolean;     // > 24h total
    complexityHigh: boolean;   // Score > 8/10
    stakeholderBlock: boolean; // DecisÃ£o externa necessÃ¡ria
  };
  
  exitStrategy: {
    documentLearnings: boolean;
    escalateToSenior: boolean;
    scheduleFollowUp: boolean;
  };
}
```

## ğŸŒ RESEARCH SISTEMÃTICO

### ğŸ” **EstratÃ©gia Multi-Canal**
```
ğŸ¯ CANAIS PRIORITÃRIOS:
1. ğŸ“š Official Documentation (sempre primeiro)
2. ğŸ™ GitHub Issues (problemas similares resolvidos)
3. ğŸ’¬ Stack Overflow (soluÃ§Ãµes da comunidade)
4. ğŸ“– Best Practices Guides (padrÃµes estabelecidos)
5. ğŸ¥ Technical Talks/Blogs (insights avanÃ§ados)
6. ğŸ‘¥ Internal Knowledge Base (experiÃªncias da equipe)
```

### ğŸ• **Time-Boxing Research**
- **âš¡ Quick Research**: 15 min para problemas simples
- **ğŸ” Deep Dive**: 30-45 min para problemas complexos
- **ğŸ¯ Focused Search**: Usar keywords especÃ­ficas + ano
- **ğŸ“‹ Document Findings**: Sempre registrar insights Ãºteis

## ğŸ§ª DEBUGGING PATTERNS

### ğŸ” **Rastreamento de Dados**
```typescript
// Service Layer - Logging defensivo
console.log('ğŸ“¥ Service Input:', JSON.stringify(params, null, 2));
console.log('ğŸ”„ Service Processing:', { step: 'validation', valid: !!data });
console.log('ğŸ“¤ Service Output:', { type: typeof result, length: result?.length });

// Component Layer - Estado e props
console.log('âš›ï¸ Component Mount:', { props, initialState });
console.log('ğŸ”„ State Change:', { from: prevState, to: newState });
console.log('ğŸ“Š Render Data:', { received: !!data, processed: processedData?.length });
```

### ğŸ¯ **Performance Debugging**
```typescript
const usePerformanceMonitor = () => {
  useEffect(() => {
    const observer = new PerformanceObserver((list) => {
      list.getEntries().forEach((entry) => {
        if (entry.entryType === 'measure') {
          analytics.track('performance_metric', {
            name: entry.name,
            duration: entry.duration,
            startTime: entry.startTime,
            component: getCurrentComponent()
          });
        }
      });
    });
    
    observer.observe({ entryTypes: ['measure'] });
    return () => observer.disconnect();
  }, []);
};
```

## ğŸš« PROIBIÃ‡Ã•ES EM DEBUGGING

- âŒ NUNCA assumir sem validar
- âŒ NUNCA investigar apenas uma hipÃ³tese por vez
- âŒ NUNCA fazer mudanÃ§as sem logging
- âŒ NUNCA parar na primeira soluÃ§Ã£o que funciona
- âŒ NUNCA deixar de documentar a causa raiz

## âœ… COMPORTAMENTOS OBRIGATÃ“RIOS

- âœ… SEMPRE usar investigaÃ§Ã£o paralela
- âœ… SEMPRE implementar logging em mÃºltiplas camadas
- âœ… SEMPRE priorizar hipÃ³teses por score
- âœ… SEMPRE documentar findings e learnings
- âœ… SEMPRE validar fix com testes abrangentes 